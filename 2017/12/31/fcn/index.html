<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="PyTorch," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="学习了沐神的 gluon 课程，觉得里面有关于 fcn 的课程 特别有用，于是总结一下，同时使用 pytorch 重新实现，不仅实现 gluon 教程中的部分，同时实现论文中更精细的形式。 介绍语义分割是一种像素级别的处理图像方式，对比于目标检测其更加精确，能够自动从图像中划分出对象区域并识别对象区域中的类别，比如下面这个效果  上面是输入的图片，下面是希望得到的效果，也就是希望能够对区域进行像素">
<meta name="keywords" content="PyTorch">
<meta property="og:type" content="article">
<meta property="og:title" content="FCN 的简单实现">
<meta property="og:url" content="https://l1aoxingyu.github.io/2017/12/31/fcn/index.html">
<meta property="og:site_name" content="Liao Xingyu&#39;s Blog">
<meta property="og:description" content="学习了沐神的 gluon 课程，觉得里面有关于 fcn 的课程 特别有用，于是总结一下，同时使用 pytorch 重新实现，不仅实现 gluon 教程中的部分，同时实现论文中更精细的形式。 介绍语义分割是一种像素级别的处理图像方式，对比于目标检测其更加精确，能够自动从图像中划分出对象区域并识别对象区域中的类别，比如下面这个效果  上面是输入的图片，下面是希望得到的效果，也就是希望能够对区域进行像素">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://ws4.sinaimg.cn/large/006tKfTcly1fmxq9pslijj30dm0e2q9p.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1fmzy877v6rj30g30bstdw.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1fmzy8hhmhuj30gw0c9jws.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1fmzy8rht5yj30dw0a63yb.jpg">
<meta property="og:image" content="https://ws4.sinaimg.cn/large/006tKfTcly1fmxwr0flouj30cg06bjsm.jpg">
<meta property="og:image" content="https://ws2.sinaimg.cn/large/006tKfTcly1fmxxmlz66dg306s077t9g.gif">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tKfTcly1fmxxn64nlyg309k0aqgps.gif">
<meta property="og:image" content="https://ws2.sinaimg.cn/large/006tKfTcgy1fmxyqu1mibj31eq0lqadr.jpg">
<meta property="og:image" content="https://ws2.sinaimg.cn/large/006tNc79ly1fmzy96b7xqj30ao067783.jpg">
<meta property="og:image" content="https://ws2.sinaimg.cn/large/006tNc79ly1fmzy9e4vayj30ar067djf.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1fmzy9q5lt3j30gy0fp420.jpg">
<meta property="og:updated_time" content="2017-12-31T06:53:18.192Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FCN 的简单实现">
<meta name="twitter:description" content="学习了沐神的 gluon 课程，觉得里面有关于 fcn 的课程 特别有用，于是总结一下，同时使用 pytorch 重新实现，不仅实现 gluon 教程中的部分，同时实现论文中更精细的形式。 介绍语义分割是一种像素级别的处理图像方式，对比于目标检测其更加精确，能够自动从图像中划分出对象区域并识别对象区域中的类别，比如下面这个效果  上面是输入的图片，下面是希望得到的效果，也就是希望能够对区域进行像素">
<meta name="twitter:image" content="https://ws4.sinaimg.cn/large/006tKfTcly1fmxq9pslijj30dm0e2q9p.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://l1aoxingyu.github.io/2017/12/31/fcn/"/>





  <title>FCN 的简单实现 | Liao Xingyu's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Liao Xingyu's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">廖星宇的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://l1aoxingyu.github.io/2017/12/31/fcn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liao Xingyu/廖星宇">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liao Xingyu's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">FCN 的简单实现</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-31T14:30:08+08:00">
                2017-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Deep-Learning/" itemprop="url" rel="index">
                    <span itemprop="name">Deep Learning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>学习了沐神的 gluon 课程，觉得里面有关于 <a href="https://zh.gluon.ai/chapter_computer-vision/fcn.html" target="_blank" rel="external">fcn 的课程</a> 特别有用，于是总结一下，同时使用 pytorch 重新实现，不仅实现 gluon 教程中的部分，同时实现论文中更精细的形式。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>语义分割是一种像素级别的处理图像方式，对比于目标检测其更加精确，能够自动从图像中划分出对象区域并识别对象区域中的类别，比如下面这个效果</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fmxq9pslijj30dm0e2q9p.jpg" alt=""></p>
<p>上面是输入的图片，下面是希望得到的效果，也就是希望能够对区域进行像素级别的划分<br><a id="more"></a></p>
<p>在 2015 年 CVPR 的一篇论文 <a href="http://link.zhihu.com/?target=https%3A//arxiv.org/abs/1411.4038" target="_blank" rel="external">Fully Convolutional Networks for Semantic Segmentation</a> 这篇文章提出了全卷积的概念，第一次将端到端的卷积网络推广到了语义分割的任务当中，随后出现了很多基于 FCN 实现的网络结构，比如 U-Net 等。</p>
<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>首先我们需要下载数据集，这里我们使用 <a href="http://host.robots.ox.ac.uk/pascal/VOC/voc2012/" target="_blank" rel="external">PASCAL VOC</a> 数据集，其是一个正在进行的目标检测,目标识别,语义分割的挑战，我们可以进行数据集的<a href="http://host.robots.ox.ac.uk/pascal/VOC/voc2012/VOCtrainval_11-May-2012.tar" target="_blank" rel="external">下载</a></p>
<p>下载完成数据集之后进行解压，我们可以再 <code>ImageSets/Segmentation/train.txt</code> 和 <code>ImageSets/Segmentation/val.txt</code> 中找到我们的训练集和验证集的数据，图片存放在 <code>/JPEGImages</code> 中，后缀是 <code>.jpg</code>，而 label 存放在 <code>/SegmentationClass</code> 中，后缀是 <code>.png</code></p>
<p>我们可以可视化一下</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fmzy877v6rj30g30bstdw.jpg" alt=""></p>
<p>首先输出图片的大小，左边就是真实的图片，右边就是分割之后的结果</p>
<p>然后我们定义一个函数进行图片的读入，根据 <code>train.txt</code> 和 <code>val.txt</code> 中的文件名进行图片读入，我们不需要这一步就读入图片，只需要知道图片的路径，之后根据图片名称生成 batch 的时候再读入图片，并做一些数据预处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">voc_root = <span class="string">'./data/VOCdevkit/VOC2012'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_images</span><span class="params">(root=voc_root, train=True)</span>:</span></div><div class="line">    txt_fname = root + <span class="string">'/ImageSets/Segmentation/'</span> + (<span class="string">'train.txt'</span> <span class="keyword">if</span> train <span class="keyword">else</span> <span class="string">'val.txt'</span>)</div><div class="line">    <span class="keyword">with</span> open(txt_fname, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">        images = f.read().split()</div><div class="line">    data = [os.path.join(root, <span class="string">'JPEGImages'</span>, i+<span class="string">'.jpg'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> images]</div><div class="line">    label = [os.path.join(root, <span class="string">'SegmentationClass'</span>, i+<span class="string">'.png'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> images]</div><div class="line">    <span class="keyword">return</span> data, label</div></pre></td></tr></table></figure>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>可能你已经注意到了前面展示的两张图片的大小是不一样的，如果我们要使用一个 batch 进行计算，我们需要图片的大小保持一致，在前面使用卷积网络进行图片分类的任务中，我们通过 resize 的办法对图片进行了缩放，使得他们的大小相同，但是这里会遇到一个问题，对于输入图片我们当然可以 resize 成任意我们想要的大小，但是 label 也是一张图片，且是在 pixel 级别上的标注，所以我们没有办法对 label 进行有效的 resize 似的其也能达到像素级别的匹配，所以为了使得输入的图片大小相同，我们就使用 crop 的方式来解决这个问题，也就是从一张图片中 crop 出固定大小的区域，然后在 label 上也做同样方式的 crop。</p>
<p>使用 crop 可以使用 pytorch 中自带的 transforms，不过要稍微改一下，不仅输出 crop 出来的区域，同时还要输出对应的坐标便于我们在 label 上做相同的 crop</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">rand_crop</span><span class="params">(data, label, height, width)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line"><span class="string">    data is PIL.Image object</span></div><div class="line"><span class="string">    label is PIL.Image object</span></div><div class="line"><span class="string">    '''</span></div><div class="line">    data, rect = tfs.RandomCrop((height, width))(data)</div><div class="line">    label = tfs.FixedCrop(*rect)(label)</div><div class="line">    <span class="keyword">return</span> data, label</div></pre></td></tr></table></figure>
<p>下面我们可以验证一下随机 crop</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fmzy8hhmhuj30gw0c9jws.jpg" alt=""></p>
<p>上面就是我们做两次随机 crop 的结果，可以看到图像和 label 能够完美的对应起来</p>
<p>接着我们根据数据知道里面有 21 中类别，同时给出每种类别对应的 RGB 值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">classes = [<span class="string">'background'</span>,<span class="string">'aeroplane'</span>,<span class="string">'bicycle'</span>,<span class="string">'bird'</span>,<span class="string">'boat'</span>,</div><div class="line">           <span class="string">'bottle'</span>,<span class="string">'bus'</span>,<span class="string">'car'</span>,<span class="string">'cat'</span>,<span class="string">'chair'</span>,<span class="string">'cow'</span>,<span class="string">'diningtable'</span>,</div><div class="line">           <span class="string">'dog'</span>,<span class="string">'horse'</span>,<span class="string">'motorbike'</span>,<span class="string">'person'</span>,<span class="string">'potted plant'</span>,</div><div class="line">           <span class="string">'sheep'</span>,<span class="string">'sofa'</span>,<span class="string">'train'</span>,<span class="string">'tv/monitor'</span>]</div><div class="line"></div><div class="line"><span class="comment"># RGB color for each class</span></div><div class="line">colormap = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">128</span>,<span class="number">0</span>], [<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>], [<span class="number">0</span>,<span class="number">0</span>,<span class="number">128</span>],</div><div class="line">            [<span class="number">128</span>,<span class="number">0</span>,<span class="number">128</span>],[<span class="number">0</span>,<span class="number">128</span>,<span class="number">128</span>],[<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>],[<span class="number">64</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">192</span>,<span class="number">0</span>,<span class="number">0</span>],</div><div class="line">            [<span class="number">64</span>,<span class="number">128</span>,<span class="number">0</span>],[<span class="number">192</span>,<span class="number">128</span>,<span class="number">0</span>],[<span class="number">64</span>,<span class="number">0</span>,<span class="number">128</span>],[<span class="number">192</span>,<span class="number">0</span>,<span class="number">128</span>],</div><div class="line">            [<span class="number">64</span>,<span class="number">128</span>,<span class="number">128</span>],[<span class="number">192</span>,<span class="number">128</span>,<span class="number">128</span>],[<span class="number">0</span>,<span class="number">64</span>,<span class="number">0</span>],[<span class="number">128</span>,<span class="number">64</span>,<span class="number">0</span>],</div><div class="line">            [<span class="number">0</span>,<span class="number">192</span>,<span class="number">0</span>],[<span class="number">128</span>,<span class="number">192</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">64</span>,<span class="number">128</span>]]</div><div class="line"></div><div class="line">len(classes), len(colormap)</div></pre></td></tr></table></figure>
<p>接着可以建立一个索引，也就是将一个类别的 RGB 值对应到一个整数上，通过这种一一对应的关系，能够将 label 图片变成一个矩阵，矩阵和原图片一样大，但是只有一个通道数，也就是 (h, w) 这种大小，里面的每个数值代表着像素的类别</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cm2lbl = np.zeros(<span class="number">256</span>**<span class="number">3</span>) <span class="comment"># 每个像素点有 0 ~ 255 的选择，RGB 三个通道</span></div><div class="line"><span class="keyword">for</span> i,cm <span class="keyword">in</span> enumerate(colormap):</div><div class="line">    cm2lbl[(cm[<span class="number">0</span>]*<span class="number">256</span>+cm[<span class="number">1</span>])*<span class="number">256</span>+cm[<span class="number">2</span>]] = i <span class="comment"># 建立索引</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">image2label</span><span class="params">(im)</span>:</span></div><div class="line">    data = np.array(im, dtype=<span class="string">'int32'</span>)</div><div class="line">    idx = (data[:, :, <span class="number">0</span>] * <span class="number">256</span> + data[:, :, <span class="number">1</span>]) * <span class="number">256</span> + data[:, :, <span class="number">2</span>]</div><div class="line">    <span class="keyword">return</span> np.array(cm2lbl[idx], dtype=<span class="string">'int64'</span>) <span class="comment"># 根据索引得到 label 矩阵</span></div></pre></td></tr></table></figure>
<p>定义完成之后，我们可以验证一下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">label_im = Image.open(<span class="string">'./data/VOCdevkit/VOC2012/SegmentationClass/2007_000033.png'</span>).convert(<span class="string">'RGB'</span>)</div><div class="line">label = image2label(label_im)</div><div class="line">label[<span class="number">150</span>:<span class="number">160</span>, <span class="number">240</span>:<span class="number">250</span>]</div></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fmzy8rht5yj30dw0a63yb.jpg" alt=""></p>
<pre><code>array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
       [1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]])
</code></pre><p>可以看到上面的像素点由 0 和 1 构成，0 表示背景，1 表示 飞机这个类别</p>
<p>接着我们可以定义数据预处理方式，之前我们读取的数据只有文件名，现在我们开始做预处理，非常简单，首先随机 crop 出固定大小的区域，然后使用 ImageNet 的均值和方差做标准化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_transforms</span><span class="params">(im, label, crop_size)</span>:</span></div><div class="line">    im, label = rand_crop(im, label, *crop_size)</div><div class="line">    im_tfs = tfs.Compose([</div><div class="line">        tfs.ToTensor(),</div><div class="line">        tfs.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</div><div class="line">    ])</div><div class="line">    </div><div class="line">    im = im_tfs(im)</div><div class="line">    label = image2label(label)</div><div class="line">    label = torch.from_numpy(label)</div><div class="line">    <span class="keyword">return</span> im, label</div></pre></td></tr></table></figure>
<p>最后我们定义一个 COVSegDataset 继承于 <code>torch.utils.data.Dataset</code> 构成我们自定的训练集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VOCSegDataset</span><span class="params">(Dataset)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line"><span class="string">    voc dataset</span></div><div class="line"><span class="string">    '''</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, train, crop_size, transforms)</span>:</span></div><div class="line">        self.crop_size = crop_size</div><div class="line">        self.transforms = transforms</div><div class="line">        data_list, label_list = read_images(train=train)</div><div class="line">        self.data_list = self._filter(data_list)</div><div class="line">        self.label_list = self._filter(label_list)</div><div class="line">        print(<span class="string">'Read '</span> + str(len(self.data_list)) + <span class="string">' images'</span>)</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_filter</span><span class="params">(self, images)</span>:</span> <span class="comment"># 过滤掉图片大小小于 crop 大小的图片</span></div><div class="line">        <span class="keyword">return</span> [im <span class="keyword">for</span> im <span class="keyword">in</span> images <span class="keyword">if</span> (Image.open(im).size[<span class="number">1</span>] &gt;= self.crop_size[<span class="number">0</span>] <span class="keyword">and</span> </div><div class="line">                                        Image.open(im).size[<span class="number">0</span>] &gt;= self.crop_size[<span class="number">1</span>])]</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, idx)</span>:</span></div><div class="line">        img = self.data_list[idx]</div><div class="line">        label = self.label_list[idx]</div><div class="line">        img = Image.open(img)</div><div class="line">        label = Image.open(label).convert(<span class="string">'RGB'</span>)</div><div class="line">        img, label = self.transforms(img, label, self.crop_size)</div><div class="line">        <span class="keyword">return</span> img, label</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> len(self.data_list)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 实例化数据集</span></div><div class="line">input_shape = (<span class="number">320</span>, <span class="number">480</span>)</div><div class="line">voc_train = VOCSegDataset(<span class="keyword">True</span>, input_shape, img_transforms)</div><div class="line">voc_test = VOCSegDataset(<span class="keyword">False</span>, input_shape, img_transforms)</div><div class="line"></div><div class="line">train_data = DataLoader(voc_train, <span class="number">64</span>, shuffle=<span class="keyword">True</span>, num_workers=<span class="number">4</span>)</div><div class="line">valid_data = DataLoader(voc_test, <span class="number">128</span>, num_workers=<span class="number">4</span>)</div></pre></td></tr></table></figure>
<h2 id="fcn-模型"><a href="#fcn-模型" class="headerlink" title="fcn 模型"></a>fcn 模型</h2><p>fcn 模型非常简单，里面全部是由卷积构成的，所以被称为全卷积网络，同时由于全卷积的特殊形式，因此可以接受任意大小的输入，网络的示意图如下</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fmxwr0flouj30cg06bjsm.jpg" alt=""></p>
<p>对于任何一张输入图片，由于卷积层和池化层的不断作用，得到的输出形状会越来越小，但是通道数会越来越大，比如 ResNet18，会将输入的长宽减小 32 倍，由 3x244x244 变成 512x7x7，也就是上图的第一部分，得到的特征图会特别小，最后通过一个转置卷积得到一个和输入形状一样的结果，这里我们引入了转置卷积的概念，下面我们讲一讲什么是转置卷积</p>
<h3 id="转置卷积"><a href="#转置卷积" class="headerlink" title="转置卷积"></a>转置卷积</h3><p>我们首先可以看看下面的动画</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fmxxmlz66dg306s077t9g.gif" alt=""></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fmxxn64nlyg309k0aqgps.gif" alt=""></p>
<p>第一张就是我们常说的卷积的效果，而转置卷积就是下面这个操作，相当于卷积的逆过程，将卷积的输入和输出反过来，卷积的正向传播相当于图片左乘一个矩阵 c，反向传播相当于左乘 $c^T$，而转置卷积的正向过程相当于左乘 $c^T$，反向过程相当于左乘 $(c^T)^T = c$，详细的推导可以看看<a href="https://arxiv.org/pdf/1603.07285.pdf" target="_blank" rel="external">论文</a></p>
<p>而转置卷积的计算公式也非常简单，对于卷积</p>
<script type="math/tex; mode=display">
n_{out} = \frac{n_{in} - kernel + 2 padding}{stride} + 1</script><p>转置卷积就是将输入和输出反过来，即</p>
<script type="math/tex; mode=display">
n_{in} = \frac{n_{out} - kernel + 2 padding}{stride} + 1</script><p>如果我们希望输出变成输入的两倍，那么 stride 取 2，kernel 和 padding 可以对应着取，比如 kernel 取 4，那么 padding 就取 1</p>
<p>在 pytorch 中转置卷积可以使用 <code>torch.nn.ConvTranspose2d()</code> 来实现，下面我们举个例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = torch.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">120</span>, <span class="number">120</span>)</div><div class="line">conv_trans = nn.ConvTranspose2d(<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</div><div class="line">y = conv_trans(Variable(x))</div><div class="line">print(y.shape)</div></pre></td></tr></table></figure>
<pre><code>torch.Size([1, 10, 240, 240])
</code></pre><p>可以看到输出变成了输入的 2 倍</p>
<h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p>最简单的 fcn 前面是一个去掉全连接层的预训练网络，然后将去掉的全连接变为 1x1 的卷积，输出和类别数目相同的通道数，比如 voc 数据集是 21 分类，那么输出的通道数就是 21，然后最后接一个转置卷积将结果变成输入的形状大小，最后在每个 pixel 上做一个分类问题，使用交叉熵作为损失函数就可以了。</p>
<p>当然这样的模型是特别粗糙的，因为最后一步直接将图片扩大了 32 倍，所以论文中有一个改进，就是将网络中间的输入联合起来进行转置卷积，这样能够依赖更多的信息，所以可以得到更好的结果，可以看看下面的图示</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmxyqu1mibj31eq0lqadr.jpg" alt=""></p>
<p>fcn-32s 就是直接将最后的结果通过转置卷积扩大 32 倍进行输出，而 fcn-16x 就是联合前面一次的结果进行 16 倍的输出，fcn-8x 就是联合前面两次的结果进行 8 倍的输出，我们用上图中 fcn-8x 举例，就是先将最后的结果通过转置卷积扩大 2 倍，然后和 pool4 的结果相加，然后在通过转置卷积扩大 2 倍，然后和 pool3 的结果相加，最后通过转置卷积扩大 8 倍得到和输入形状一样大的结果。</p>
<h3 id="bilinear-kernel"><a href="#bilinear-kernel" class="headerlink" title="bilinear kernel"></a>bilinear kernel</h3><p>通常我们训练的时候可以随机初始化权重，但是在 fcn 的网络中，使用随机初始化的权重将会需要大量的时间进行训练，所以我们卷积层可以使用在 imagenet 上预训练的权重，那么转置卷积我们使用什么样的初始权重呢？这里就要用到 bilinear kernel。</p>
<p>我们可以看看下面的例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义 bilinear kernel</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bilinear_kernel</span><span class="params">(in_channels, out_channels, kernel_size)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line"><span class="string">    return a bilinear filter tensor</span></div><div class="line"><span class="string">    '''</span></div><div class="line">    factor = (kernel_size + <span class="number">1</span>) // <span class="number">2</span></div><div class="line">    <span class="keyword">if</span> kernel_size % <span class="number">2</span> == <span class="number">1</span>:</div><div class="line">        center = factor - <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        center = factor - <span class="number">0.5</span></div><div class="line">    og = np.ogrid[:kernel_size, :kernel_size]</div><div class="line">    filt = (<span class="number">1</span> - abs(og[<span class="number">0</span>] - center) / factor) * (<span class="number">1</span> - abs(og[<span class="number">1</span>] - center) / factor)</div><div class="line">    weight = np.zeros((in_channels, out_channels, kernel_size, kernel_size), dtype=<span class="string">'float32'</span>)</div><div class="line">    weight[range(in_channels), range(out_channels), :, :] = filt</div><div class="line">    <span class="keyword">return</span> torch.from_numpy(weight)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = Image.open(<span class="string">'./data/VOCdevkit/VOC2012/JPEGImages/2007_005210.jpg'</span>)</div><div class="line">x = np.array(x)</div><div class="line">plt.imshow(x)</div><div class="line">print(x.shape)</div></pre></td></tr></table></figure>
<pre><code>(281, 500, 3)
</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fmzy96b7xqj30ao067783.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">x = torch.from_numpy(x.astype(<span class="string">'float32'</span>)).permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>).unsqueeze(<span class="number">0</span>)</div><div class="line"><span class="comment"># 定义转置卷积</span></div><div class="line">conv_trans = nn.ConvTranspose2d(<span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>)</div><div class="line"><span class="comment"># 将其定义为 bilinear kernel</span></div><div class="line">conv_trans.weight.data = bilinear_kernel(<span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"></div><div class="line">y = conv_trans(Variable(x)).data.squeeze().permute(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>).numpy()</div><div class="line">plt.imshow(y.astype(<span class="string">'uint8'</span>))</div><div class="line">print(y.shape)</div></pre></td></tr></table></figure>
<pre><code>(562, 1000, 3)
</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fmzy9e4vayj30ar067djf.jpg" alt=""></p>
<p>可以看到通过双线性的 kernel 进行转置卷积，图片的大小扩大了一倍，但是图片看上去仍然非常的清楚，所以这种方式的上采样具有很好的效果</p>
<p>下面我们使用 resnet 34 代替论文中的 vgg 实现 fcn</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 使用预训练的 resnet 34</span></div><div class="line">pretrained_net = model_zoo.resnet34(pretrained=<span class="keyword">True</span>)</div><div class="line">num_classes = len(classes)</div></pre></td></tr></table></figure>
<p>这里我们去掉最后的 avgpool 和 fc 层，使用 <code>list(pretrained_net.children())[:-2]</code> 就能够取到倒数第三层</p>
<p>下面我们开始定义我们的网络结构，就像上面显示的一样，我们会取出最后的三个结果进行合并</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">fcn</span><span class="params">(nn.Module)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_classes)</span>:</span></div><div class="line">        super(fcn, self).__init__()</div><div class="line"></div><div class="line">        self.stage1 = nn.Sequential(*list(pretrained_net.children())[:<span class="number">-4</span>]) <span class="comment"># 第一段</span></div><div class="line">        self.stage2 = list(pretrained_net.children())[<span class="number">-4</span>] <span class="comment"># 第二段</span></div><div class="line">        self.stage3 = list(pretrained_net.children())[<span class="number">-3</span>] <span class="comment"># 第三段</span></div><div class="line">        </div><div class="line">        self.scores1 = nn.Conv2d(<span class="number">512</span>, num_classes, <span class="number">1</span>)</div><div class="line">        self.scores2 = nn.Conv2d(<span class="number">256</span>, num_classes, <span class="number">1</span>)</div><div class="line">        self.scores3 = nn.Conv2d(<span class="number">128</span>, num_classes, <span class="number">1</span>)</div><div class="line">        </div><div class="line">        self.upsample_8x = nn.ConvTranspose2d(num_classes, num_classes, <span class="number">16</span>, <span class="number">8</span>, <span class="number">4</span>, bias=<span class="keyword">False</span>)</div><div class="line">        self.upsample_8x.weight.data = bilinear_kernel(num_classes, num_classes, <span class="number">16</span>) <span class="comment"># 使用双线性 kernel</span></div><div class="line">        </div><div class="line">        self.upsample_4x = nn.ConvTranspose2d(num_classes, num_classes, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, bias=<span class="keyword">False</span>)</div><div class="line">        self.upsample_4x.weight.data = bilinear_kernel(num_classes, num_classes, <span class="number">4</span>) <span class="comment"># 使用双线性 kernel</span></div><div class="line">        </div><div class="line">        self.upsample_2x = nn.ConvTranspose2d(num_classes, num_classes, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, bias=<span class="keyword">False</span>)   </div><div class="line">        self.upsample_2x.weight.data = bilinear_kernel(num_classes, num_classes, <span class="number">4</span>) <span class="comment"># 使用双线性 kernel</span></div><div class="line"></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></div><div class="line">        x = self.stage1(x)</div><div class="line">        s1 = x <span class="comment"># 1/8</span></div><div class="line">        </div><div class="line">        x = self.stage2(x)</div><div class="line">        s2 = x <span class="comment"># 1/16</span></div><div class="line">        </div><div class="line">        x = self.stage3(x)</div><div class="line">        s3 = x <span class="comment"># 1/32</span></div><div class="line">        </div><div class="line">        s3 = self.scores1(s3)</div><div class="line">        s3 = self.upsample_2x(s3)</div><div class="line">        s2 = self.scores2(s2)</div><div class="line">        s2 = s2 + s3</div><div class="line">        </div><div class="line">        s1 = self.scores3(s1)</div><div class="line">        s2 = self.upsample_4x(s2)</div><div class="line">        s = s1 + s2</div><div class="line"></div><div class="line">        s = self.upsample_8x(s2)</div><div class="line">        <span class="keyword">return</span> s</div></pre></td></tr></table></figure>
<p>接着我们定义一些语义分割常用的指标，比如 overal accuracy，mean IU 等等，下面这个是参考 wkentaro 的 <a href="https://github.com/wkentaro/pytorch-fcn/blob/master/torchfcn/utils.py" target="_blank" rel="external">pytorch-fcn</a> 得到的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_fast_hist</span><span class="params">(label_true, label_pred, n_class)</span>:</span></div><div class="line">    mask = (label_true &gt;= <span class="number">0</span>) &amp; (label_true &lt; n_class)</div><div class="line">    hist = np.bincount(</div><div class="line">        n_class * label_true[mask].astype(int) +</div><div class="line">        label_pred[mask], minlength=n_class ** <span class="number">2</span>).reshape(n_class, n_class)</div><div class="line">    <span class="keyword">return</span> hist</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">label_accuracy_score</span><span class="params">(label_trues, label_preds, n_class)</span>:</span></div><div class="line">    <span class="string">"""Returns accuracy score evaluation result.</span></div><div class="line"><span class="string">      - overall accuracy</span></div><div class="line"><span class="string">      - mean accuracy</span></div><div class="line"><span class="string">      - mean IU</span></div><div class="line"><span class="string">      - fwavacc</span></div><div class="line"><span class="string">    """</span></div><div class="line">    hist = np.zeros((n_class, n_class))</div><div class="line">    <span class="keyword">for</span> lt, lp <span class="keyword">in</span> zip(label_trues, label_preds):</div><div class="line">        hist += _fast_hist(lt.flatten(), lp.flatten(), n_class)</div><div class="line">    acc = np.diag(hist).sum() / hist.sum()</div><div class="line">    acc_cls = np.diag(hist) / hist.sum(axis=<span class="number">1</span>)</div><div class="line">    acc_cls = np.nanmean(acc_cls)</div><div class="line">    iu = np.diag(hist) / (hist.sum(axis=<span class="number">1</span>) + hist.sum(axis=<span class="number">0</span>) - np.diag(hist))</div><div class="line">    mean_iu = np.nanmean(iu)</div><div class="line">    freq = hist.sum(axis=<span class="number">1</span>) / hist.sum()</div><div class="line">    fwavacc = (freq[freq &gt; <span class="number">0</span>] * iu[freq &gt; <span class="number">0</span>]).sum()</div><div class="line">    <span class="keyword">return</span> acc, acc_cls, mean_iu, fwavacc</div></pre></td></tr></table></figure>
<p>然后我们定义 loss，这里使用 <code>torch.nn.NLLLoss2d()</code>，其实这和交叉熵一样，都是处理分类问题的 loss，只是这个 loss 需要在最后一层输出加上 <code>torch.nn.functional.log_softmax</code>，但是这个 loss 可以作用在 2d 的输出上，于是我们就选择这个 loss</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义 loss 和 optimizer</span></div><div class="line"><span class="keyword">from</span> mxtorch.trainer <span class="keyword">import</span> ScheduledOptim</div><div class="line">criterion = nn.NLLLoss2d()</div><div class="line">basic_optim = torch.optim.SGD(net.parameters(), lr=<span class="number">1e-2</span>, weight_decay=<span class="number">1e-4</span>)</div><div class="line">optimizer = ScheduledOptim(basic_optim)</div></pre></td></tr></table></figure>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(<span class="number">80</span>):</div><div class="line">    <span class="keyword">if</span> e &gt; <span class="number">0</span> <span class="keyword">and</span> e % <span class="number">50</span> == <span class="number">0</span>:</div><div class="line">        optimizer.set_learning_rate(optimizer.learning_rate * <span class="number">0.1</span>)</div><div class="line">    train_loss = <span class="number">0</span></div><div class="line">    train_acc = <span class="number">0</span></div><div class="line">    train_acc_cls = <span class="number">0</span></div><div class="line">    train_mean_iu = <span class="number">0</span></div><div class="line">    train_fwavacc = <span class="number">0</span></div><div class="line">    </div><div class="line">    prev_time = datetime.now()</div><div class="line">    net = net.train()</div><div class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_data:</div><div class="line">        im = Variable(data[<span class="number">0</span>].cuda())</div><div class="line">        label = Variable(data[<span class="number">1</span>].cuda())</div><div class="line">        <span class="comment"># forward</span></div><div class="line">        out = net(im)</div><div class="line">        out = F.log_softmax(out, dim=<span class="number">1</span>) <span class="comment"># (b, n, h, w)</span></div><div class="line">        loss = criterion(out, label)</div><div class="line">        <span class="comment"># backward</span></div><div class="line">        optimizer.zero_grad()</div><div class="line">        loss.backward()</div><div class="line">        optimizer.step()</div><div class="line">        train_loss += loss.data[<span class="number">0</span>]</div><div class="line">        </div><div class="line">        label_pred = out.max(dim=<span class="number">1</span>)[<span class="number">1</span>].data.cpu().numpy()</div><div class="line">        label_true = label.data.cpu().numpy()</div><div class="line">        <span class="keyword">for</span> lbt, lbp <span class="keyword">in</span> zip(label_true, label_pred):</div><div class="line">            acc, acc_cls, mean_iu, fwavacc = label_accuracy_score(lbt, lbp, num_classes)</div><div class="line">            train_acc += acc</div><div class="line">            train_acc_cls += acc_cls</div><div class="line">            train_mean_iu += mean_iu</div><div class="line">            train_fwavacc += fwavacc</div><div class="line">        </div><div class="line">    net = net.eval()</div><div class="line">    eval_loss = <span class="number">0</span></div><div class="line">    eval_acc = <span class="number">0</span></div><div class="line">    eval_acc_cls = <span class="number">0</span></div><div class="line">    eval_mean_iu = <span class="number">0</span></div><div class="line">    eval_fwavacc = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> valid_data:</div><div class="line">        im = Variable(data[<span class="number">0</span>].cuda(), volatile=<span class="keyword">True</span>)</div><div class="line">        label = Variable(data[<span class="number">1</span>].cuda(), volatile=<span class="keyword">True</span>)</div><div class="line">        <span class="comment"># forward</span></div><div class="line">        out = net(im)</div><div class="line">        out = F.log_softmax(out, dim=<span class="number">1</span>)</div><div class="line">        loss = criterion(out, label)</div><div class="line">        eval_loss += loss.data[<span class="number">0</span>]</div><div class="line">        </div><div class="line">        label_pred = out.max(dim=<span class="number">1</span>)[<span class="number">1</span>].data.cpu().numpy()</div><div class="line">        label_true = label.data.cpu().numpy()</div><div class="line">        <span class="keyword">for</span> lbt, lbp <span class="keyword">in</span> zip(label_true, label_pred):</div><div class="line">            acc, acc_cls, mean_iu, fwavacc = label_accuracy_score(lbt, lbp, num_classes)</div><div class="line">            eval_acc += acc</div><div class="line">            eval_acc_cls += acc_cls</div><div class="line">            eval_mean_iu += mean_iu</div><div class="line">            eval_fwavacc += fwavacc</div><div class="line">        </div><div class="line">    cur_time = datetime.now()</div><div class="line">    h, remainder = divmod((cur_time - prev_time).seconds, <span class="number">3600</span>)</div><div class="line">    m, s = divmod(remainder, <span class="number">60</span>)</div><div class="line">    epoch_str = (<span class="string">'Epoch: &#123;&#125;, Train Loss: &#123;:.5f&#125;, Train Acc: &#123;:.5f&#125;, Train Mean IU: &#123;:.5f&#125;, \</span></div><div class="line"><span class="string">Valid Loss: &#123;:.5f&#125;, Valid Acc: &#123;:.5f&#125;, Valid Mean IU: &#123;:.5f&#125; '</span>.format(</div><div class="line">        e, train_loss / len(train_data), train_acc / len(voc_train), train_mean_iu / len(voc_train),</div><div class="line">        eval_loss / len(valid_data), eval_acc / len(voc_test), eval_mean_iu / len(voc_test)))</div><div class="line">    time_str = <span class="string">'Time: &#123;:.0f&#125;:&#123;:.0f&#125;:&#123;:.0f&#125;'</span>.format(h, m, s)</div><div class="line">    print(epoch_str + time_str + <span class="string">' lr: &#123;&#125;'</span>.format(optimizer.learning_rate))</div></pre></td></tr></table></figure>
<pre><code>Epoch: 77, Train Loss: 0.23017, Train Acc: 0.92420, Train Mean IU: 0.64684, Valid Loss: 0.39680, Valid Acc: 0.87509, Valid Mean IU: 0.53005 Time: 0:0:41 lr: 0.001
Epoch: 78, Train Loss: 0.23212, Train Acc: 0.92334, Train Mean IU: 0.64237, Valid Loss: 0.39651, Valid Acc: 0.87538, Valid Mean IU: 0.52885 Time: 0:0:41 lr: 0.001
Epoch: 79, Train Loss: 0.23251, Train Acc: 0.92364, Train Mean IU: 0.64002, Valid Loss: 0.39242, Valid Acc: 0.87575, Valid Mean IU: 0.53311 Time: 0:0:41 lr: 0.001
</code></pre><p>可以看到，我们的模型在训练集上的 mean IU 达到了 0.64 左右，验证集上的 mean IU 达到了 0.53 左右，下面我们可视化一下最后的结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义预测函数</span></div><div class="line">cm = np.array(colormap).astype(<span class="string">'uint8'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(im, label)</span>:</span> <span class="comment"># 预测结果</span></div><div class="line">    im = Variable(im.unsqueeze(<span class="number">0</span>)).cuda()</div><div class="line">    out = net(im)</div><div class="line">    pred = out.max(<span class="number">1</span>)[<span class="number">1</span>].squeeze().cpu().data.numpy()</div><div class="line">    pred = cm[pred]</div><div class="line">    <span class="keyword">return</span> pred, cm[label.numpy()]</div><div class="line"></div><div class="line"></div><div class="line">_, figs = plt.subplots(<span class="number">6</span>, <span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">10</span>))</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</div><div class="line">    test_data, test_label = voc_test[i]</div><div class="line">    pred, label = predict(test_data, test_label)</div><div class="line">    figs[i, <span class="number">0</span>].imshow(Image.open(voc_test.data_list[i]))</div><div class="line">    figs[i, <span class="number">0</span>].axes.get_xaxis().set_visible(<span class="keyword">False</span>)</div><div class="line">    figs[i, <span class="number">0</span>].axes.get_yaxis().set_visible(<span class="keyword">False</span>)</div><div class="line">    figs[i, <span class="number">1</span>].imshow(label)</div><div class="line">    figs[i, <span class="number">1</span>].axes.get_xaxis().set_visible(<span class="keyword">False</span>)</div><div class="line">    figs[i, <span class="number">1</span>].axes.get_yaxis().set_visible(<span class="keyword">False</span>)</div><div class="line">    figs[i, <span class="number">2</span>].imshow(pred)</div><div class="line">    figs[i, <span class="number">2</span>].axes.get_xaxis().set_visible(<span class="keyword">False</span>)</div><div class="line">    figs[i, <span class="number">2</span>].axes.get_yaxis().set_visible(<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fmzy9q5lt3j30gy0fp420.jpg" alt=""></p>
<p>可以看到，通过训练，模型已经有了基本效果，但是离论文中的效果有差距，有可能是训练的问题，更多的原因应该是没有使用 caffe model 中的 vgg 模型，这里特别提醒一下，如果要使用 caffe model，那么图像预处理的时候要是 BRG 的格式，同时大小是 0 ~ 255，减去均值。</p>
<p>另外代码中使用的 mxtorch 可以在我的 github 主页看到</p>
<hr>
<p>本文的<a href="https://github.com/SherlockLiao/code-of-learn-deep-learning-with-pytorch/blob/master/chapter9_Computer-Vision/segmentation/fcn.ipynb" target="_blank" rel="external">代码</a></p>
<p>欢迎查看我的知乎专栏，<a href="https://zhuanlan.zhihu.com/c_94953554" target="_blank" rel="external">深度炼丹</a></p>
<p>欢迎访问我的<a href="https://sherlockliao.github.io/" target="_blank" rel="external">博客</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/PyTorch/" rel="tag"># PyTorch</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/26/如何找到最好的学习率/" rel="next" title="如何找到最优学习率">
                <i class="fa fa-chevron-left"></i> 如何找到最优学习率
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/04/如何用flask部署pytorch模型/" rel="prev" title="如何用flask部署pytorch模型">
                如何用flask部署pytorch模型 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Liao Xingyu/廖星宇" />
          <p class="site-author-name" itemprop="name">Liao Xingyu/廖星宇</p>
           
              <p class="site-description motion-element" itemprop="description">关于人工智能和深度学习 | 廖星宇，Deep Learner & 健身爱好者 | 这里是 @Sherlock 廖星宇 的个人博客，I want to create some new things!</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">44</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据集"><span class="nav-number">2.</span> <span class="nav-text">数据集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据预处理"><span class="nav-number">3.</span> <span class="nav-text">数据预处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fcn-模型"><span class="nav-number">4.</span> <span class="nav-text">fcn 模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#转置卷积"><span class="nav-number">4.1.</span> <span class="nav-text">转置卷积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模型结构"><span class="nav-number">4.2.</span> <span class="nav-text">模型结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bilinear-kernel"><span class="nav-number">4.3.</span> <span class="nav-text">bilinear kernel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#训练"><span class="nav-number">4.4.</span> <span class="nav-text">训练</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liao Xingyu/廖星宇</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">Theme &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
